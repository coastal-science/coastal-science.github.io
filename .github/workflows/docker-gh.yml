# Sample workflow for building and deploying a Hugo site to GitHub Pages
name: Build and deploy docker image of Hugo site [GitHub.com]
run-name: docker build

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

on:
  schedule:
  - cron: '37 12 * * *'
  push:
    branches: [ "main", "gha-docker" ]
    # Publish semver tags as releases.
    # tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ "main" ]
  workflow_call:
    # allows reusing the workflow
  workflow_dispatch:

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: ${{ github.repository }}

# environment: [staging, production]
# TODO
# permissions: 
#   actions: read
#   # checks: write
#   contents: read
#   # deployments: read|write|none
#   packages: write
#   statuses: read|write|none

jobs:
  build:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}
      cancel-in-progress: true
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        path: ${{ env.THIS_DEPLOY_REPO }}

    - name: Check out the other (viewer) repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/${{ env.VIEWER_REPO }}
        path: ${{ env.VIEWER_REPO }}
        ref: ${{ env.VIEWER_REPO_BRANCH }}
        fetch-tags: true

    - name: List repos in workspace
      run: |
        # touch ${{ env.VIEWER_REPO }}/catalogs/index.yaml
        ls -lah
        du -sh *
        echo The current builder repo is: ${{ env.THIS_DEPLOY_REPO }}
        pwd

    - name: Check out the other (files private) repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/${{ vars.CATALOG_FILES_1 }}
        ref: ${{ env.FILES_REPO_BRANCH }}
        path: ${{ vars.CATALOG_FILES_1 }}
        token: ${{ secrets.PULL_TOKEN }}
        # token: ${{ secrets.GITHUB_TOKEN }}
        fetch-tags: true

    - name: Check out the other (files private) repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/${{ vars.CATALOG_FILES_2 }}
        ref: ${{ env.FILES_REPO_BRANCH }}
        path: ${{ vars.CATALOG_FILES_2 }}
        token: ${{ secrets.PULL_TOKEN }}
        # token: ${{ secrets.GITHUB_TOKEN }}
        fetch-tags: true

    - name: Check out the other (files private) repo
      uses: actions/checkout@v4
      with:
        repository: ${{ github.repository_owner }}/${{ vars.CATALOG_FILES_3 }}
        ref: ${{ env.FILES_REPO_BRANCH }}
        path: ${{ vars.CATALOG_FILES_3 }}
        token: ${{ secrets.PULL_TOKEN }}
        # token: ${{ secrets.GITHUB_TOKEN }}
        fetch-tags: true

    - name: List repos in workspace
      run: |
        ls -lah
        du -sh *
        echo The current files repo is: ${{ env.REPOS }}

    - name: Check tags in repositories
      id: type-of-build
      env:
        REPOS: ${{ env.REPO_FILES }}

      run: |
        REPOS=( "${{ env.VIEWER_REPO }}" ${REPOS} )
        ALL_PROD=true
        SEMVER_REGEX="^(v\.?|v)?[0-9]+\.[0-9]+\.[0-9]+$"
        for REPO in "${REPOS[@]}"; do
          cd $REPO
          TAGS=$(git tag --points-at HEAD | head )
          echo $REPO tag is $TAGS
          if [[ $TAGS != *"prod"* && $TAGS != *"release"* && ! $TAGS =~ $SEMVER_REGEX ]]; then
            ALL_PROD=false
            break
          fi
          cd -
        done

        if [ "$ALL_PROD" = true ] && [ "${{env.TYPE_OF_BUILD}}" = "latest" ]; then
          echo "TYPE_OF_BUILD=latest" >> "$GITHUB_ENV"
          echo "TYPE_OF_BUILD=latest" >> "$GITHUB_OUTPUT"
          TYPE_OF_BUILD=latest
        else
          echo "TYPE_OF_BUILD=dev" >> "$GITHUB_ENV"
          echo "TYPE_OF_BUILD=dev" >> "$GITHUB_OUTPUT"
          TYPE_OF_BUILD=dev
        fi
        echo "The type of build is: ${TYPE_OF_BUILD}"

    - name: Run tag builder manually
      id: tag-builder
      env:
        REPOS: ${{ env.REPO_FILES }}
      run: |
        cd ${{ env.THIS_DEPLOY_REPO }}
        # echo '"{ "auths": {"ghcr.io": {}, "registry.rcg.sfu.ca": {}}}"' | tee ~/.docker/config.json

        source utils.sh # import helper functions
        echo Building ${REPOS}
        if [ $1 ]; then 
          # if there are any more input args, they are paths to local repositories
          REPOS=(${@:1})
        else
          echo No args paths to local repos, using default.
          # REPOS=("../call-catalog-viewer" "../${FILES_REPO}" )
          REPOS=( ${REPOS} )
          REPOS=("${REPOS[@]/#/../}") # add prefix "../"
        fi
        echo Using: $'\t' ${REPOS[@]}

        tag_builder=""

        # Iterate in reverse
        base_dir=$(pwd)
        numelems=$((${#REPOS[@]}-1)) 
        for ((i=${numelems}; i>=0; i--)); do
            # add them in reverse order so that the first item is processed first while using the pushd/popd stack
            pushd ${REPOS[$i]} > /dev/null # add directories to process to the stack
        done
        pushd ${base_dir} > /dev/null

        echo
        echo Dir stack: $(dirs) # see directories on stack

        # Iterate over each repository
        for REPO in "${REPOS[@]}"; do
            echo 
            echo "Checking repository: $REPO"

            # Change to the repository directory
            popd
            
            tags=$(get_stamp)
            echo $tags
            tag_builder+=_$tags
        done
        pushd ${base_dir} > /dev/null

        tag_builder=${tag_builder:1} # remove leading _ from the loop
        TAG="$(date +'%Y%m%d-%H%M')" 
        EXTRA_TAG="${tag_builder:0:128}"

        echo "TAG=${TAG-random}" >> "$GITHUB_OUTPUT"
        echo "EXTRA_TAG=${EXTRA_TAG}" >> "$GITHUB_OUTPUT"
        echo ${TAG} ${EXTRA_TAG}

    - name: Run image builder manually
      env:
        TYPE_OF_BUILD: ${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}
        IMAGE_NAME: ${{ env.IMAGE_NAME }}
        ORGANIZATION: ${{ github.repository_owner }}
        CONTAINER_REGISTRY: ${{ env.REGISTRY }}
        # REGISTRY: ${{ env.CONTAINER_REGISTRY }}/${{ env.ORGANIZATION }}
        REGISTRY: ${{ env.REGISTRY }}/${{ github.repository_owner }}

        TAG: ${{ steps.tag-builder.outputs.TAG }}
        EXTRA_TAG: ${{ steps.tag-builder.outputs.EXTRA_TAG }}

        VERSION: ${{ vars.POPULATION }}-${{ steps.tag-builder.outputs.TAG }}
        USERNAME: ${{ secrets.USERNAME }}
        CR_PAT: ${{ secrets.token }}
      run: |
        cd ${{ env.THIS_DEPLOY_REPO }}

        # time ./pull_build.sh -dev
        echo REGISTRY=${REGISTRY}. VERSION=${VERSION}. EXTRA_TAG=${EXTRA_TAG}.
        echo No need to run docker builder manually anymore. Deferring build to GitHub Actions.

    # Install the cosign tool except on PR
    # https://github.com/sigstore/cosign-installer
    - name: Install cosign
      if: github.event_name != 'pull_request'
      uses: sigstore/cosign-installer@59acb6260d9c0ba8f4a2f9d9b48431a222b68e20 #v3.5.0
      with:
        cosign-release: 'v2.2.4'

    # Set up BuildKit Docker container builder to be able to build
    # multi-platform images and export cache
    # https://github.com/docker/setup-buildx-action
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0

    # Login against a Docker registry except on PR
    # https://github.com/docker/login-action
    - name: Log into registry ${{ env.REGISTRY }}
      if: github.event_name != 'pull_request'
      uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Extract metadata (tags, labels) for Docker
    # https://github.com/docker/metadata-action
    - name: Extract Docker metadata
      id: meta
      uses: docker/metadata-action@96383f45573cb7f253c731d3b3ab81c87ef81934 # v5.0.0
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

    # Build and push Docker image with Buildx (don't push on PR)
    # https://github.com/docker/build-push-action
    - name: Build and push Docker image
      id: build-and-push
      uses: docker/build-push-action@0565240e2d4ab88bba5387d719585280857ece09 # v5.0.0
      with:
        # context: .
        context: call-library
        file: ${{ env.THIS_DEPLOY_REPO }}/Dockerfile.multi.alma
        build-contexts: |
          viewer=call-catalog-viewer
          srkwfiles=${{ vars.CATALOG_FILES_1 }}
          nrkwfiles=${{ vars.CATALOG_FILES_2 }}
          wctkwfiles=${{ vars.CATALOG_FILES_3 }}
        # cataloguefiles=${{ env.FILES_REPO }}
        build-args: |
          branch=johnford
          VERSION=${{ vars.POPULATION }}-${{ steps.tag-builder.outputs.TAG }}
          CATALOG_NAME_1=${{ vars.POPULATION_1 }}
          CATALOG_FILES_1=${{ vars.CATALOG_FILES_1 }}
          CATALOG_NAME_2=${{ vars.POPULATION_2 }}
          CATALOG_NAME_3=${{ vars.POPULATION_3 }}
        # SRKW
        # srkw-call-catalogue-files
        # NRKW
        # WCTKW
        # CATALOG_NAME=${{ vars.POPULATION }}
        # CATALOG_FILES=${{ env.FILES_REPO }}

        target: ${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}
        platforms: |
          linux/amd64
        # push: ${{ github.event_name != 'pull_request' }}
        push: true
        tags: ${{ steps.meta.outputs.tags }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.type-of-build.outputs.TYPE_OF_BUILD }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag-builder.outputs.TAG }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag-builder.outputs.EXTRA_TAG }}
        labels: ${{ steps.meta.outputs.labels }}
        # cache-from: type=gha
        # cache-to: type=gha,mode=max
        # cache-from: type=local,src=/docker-cache
        # cache-to: type=local,dest=/docker-cache,mode=max

    # Sign the resulting Docker image digest except on PRs.
    # This will only write to the public Rekor transparency log when the Docker
    # repository is public to avoid leaking data.  If you would like to publish
    # transparency data even for private images, pass --force to cosign below.
    # https://github.com/sigstore/cosign
    - name: Sign the published Docker image
      if: ${{ github.event_name != 'pull_request' }}
      env:
        # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
        TAGS: ${{ steps.meta.outputs.tags }}
        DIGEST: ${{ steps.build-and-push.outputs.digest }}
      # This step uses the identity token to provision an ephemeral certificate
      # against the sigstore community Fulcio instance.
      run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}

    - name: Deploy backend nomad job
      run: |
        echo "Attempting backend deployment: population=${{ vars.POPULATION }} type=${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}"
        cd call-library/nomad/

        export POPULATION=${{ vars.POPULATION }}; 
        export TYPE=${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}; 
        envsubst < call-catalogue-single.nomad.template > $POPULATION-call-catalogue-$TYPE.nomad

        nomad job stop -address="http://192.168.245.224:4646" -token=${{ secrets.NOMAD_TOKEN }} \
            $POPULATION-call-catalogue-$TYPE || true
        nomad run -verbose -address="http://192.168.245.224:4646" -token=${{ secrets.NOMAD_TOKEN }} \
            -var "type=${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}" \
            -var "population=${{ vars.POPULATION }}" \
            $POPULATION-call-catalogue-$TYPE.nomad

        echo deployed to https://${{ vars.POPULATION }}-${{ steps.type-of-build.outputs.TYPE_OF_BUILD }}.***.***.ca
        cd -

  cleanup:
    if: always()
    needs: [ build ]
    environment: ${{ matrix.environment }}
    # runs-on: ubuntu-latest
    runs-on: self-hosted
    concurrency:
      group: ${{ github.workflow }}-${{ matrix.environment }}
    steps:
    - name: Cleanup
      run: |
        ls -lah
        du -sh

        echo Clearing the current folder.
        rm -rf *

        ls -lah
        du -sh